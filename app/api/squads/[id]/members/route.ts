import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { requireAuth } from '@/lib/auth'



interface RouteParams {
  params: Promise<{
    id: string // squadId
  }>
}

// POST: Add athlete to squad
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const user = await requireAuth()
    const { id: squadId } = await params
    const { athleteId, position } = await request.json()

    // Check permissions (coach or admin)
    if (user.role !== 'coach' && user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Only coaches and admins can manage squads' },
        { status: 403 }
      )
    }

    // Check squad capacity and team-only requirements
    const squad = await prisma.squad.findUnique({
      where: { id: squadId },
      include: {
        members: {
          include: {
            athlete: {
              include: {
                team: true
              }
            }
          }
        }
      }
    })

    if (!squad) {
      return NextResponse.json({ error: 'Squad not found' }, { status: 404 })
    }

    if (squad.members.length >= squad.capacity) {
      return NextResponse.json(
        { error: 'Squad is at full capacity' },
        { status: 400 }
      )
    }

    // Check if athlete is already in this squad
    const existing = await prisma.squadMember.findUnique({
      where: {
        squadId_athleteId: {
          squadId,
          athleteId
        }
      }
    })

    if (existing) {
      return NextResponse.json(
        { error: 'Athlete is already in this squad' },
        { status: 400 }
      )
    }

    // If squad is team-only, enforce team requirement
    if (squad.teamOnly && squad.members.length > 0) {
      // Get the athlete being added
      const newAthlete = await prisma.athlete.findUnique({
        where: { id: athleteId },
        include: { team: true }
      })

      // Get team of existing squad members
      const existingTeamIds = squad.members.map((m: { athlete: { teamId: string | null } }) => m.athlete.teamId).filter(Boolean)
      const firstTeamId = existingTeamIds[0]

      // Check if new athlete is from the same team
      if (newAthlete && newAthlete.teamId !== firstTeamId) {
        const firstTeamName = squad.members[0]?.athlete.team?.name || 'the existing team'
        return NextResponse.json(
          { 
            error: `This is a team-only squad for ${firstTeamName}. Only athletes from ${firstTeamName} can be added.` 
          },
          { status: 400 }
        )
      }

      // Check if athlete has no team
      if (!newAthlete || !newAthlete.teamId) {
        return NextResponse.json(
          { error: 'This is a team-only squad. This athlete must be on a team to join.' },
          { status: 400 }
        )
      }
    }

    // Auto-assign position if not provided
    let finalPosition = position
    if (!finalPosition) {
      // Get the highest position in the squad
      const highestPosition = await prisma.squadMember.findFirst({
        where: { squadId },
        orderBy: { position: 'desc' },
        select: { position: true }
      })
      finalPosition = (highestPosition?.position || 0) + 1
    }

    // Add athlete to squad
    const member = await prisma.squadMember.create({
      data: {
        squadId,
        athleteId,
        position: finalPosition
      },
      include: {
        athlete: {
          include: {
            user: true,
            team: true
          }
        }
      }
    })

    // Auto-update squad name ONLY if it matches an auto-generated pattern
    const updatedSquad = await prisma.squad.findUnique({
      where: { id: squadId },
      include: {
        members: {
          include: {
            athlete: {
              include: {
                team: true
              }
            }
          }
        }
      }
    })

    // Check if squad name matches auto-generated pattern
    // Auto-generated names start with division name followed by number (e.g., "Open 1", "Varsity 2")
    // Custom names have additional text before division (e.g., "High Plains Drifters - Open 1")
    const divisionPrefixes = ['Open', 'Varsity', 'Intermediate', 'Junior Varsity', 'Novice', 'Collegiate', 'Unassigned']
    const isAutoGeneratedName = divisionPrefixes.some(prefix =>
      new RegExp(`^${prefix}\\s+\\d+$`).test(updatedSquad?.name || '')
    )

    if (updatedSquad && updatedSquad.members.length > 0 && isAutoGeneratedName) {
      // Get unique team IDs and names (filtering out null/undefined)
      const teams = updatedSquad.members
        .map(m => m.athlete.team)
        .filter((team): team is NonNullable<typeof team> => team !== null)

      const uniqueTeams = [...new Map(teams.map(t => [t.id, t])).values()]

      // Get divisions from squad members (use divisionOverride if available, otherwise division)
      const divisions = updatedSquad.members
        .map(m => m.athlete.divisionOverride || m.athlete.division)
        .filter(Boolean)

      const uniqueDivisions = [...new Set(divisions)]

      let baseSquadName: string

      // If multiple divisions (mixed divisions), use "Open" format
      if (uniqueDivisions.length > 1) {
        baseSquadName = 'Open'
      } else if (uniqueDivisions.length === 1 && uniqueDivisions[0]) {
        // Single division: use just the division name (e.g., "Varsity", "Junior Varsity", "Novice")
        baseSquadName = uniqueDivisions[0]
      } else {
        // Fallback
        baseSquadName = 'Open'
      }

      // Get all squads for this time slot to determine the number suffix
      const timeSlotSquads = await prisma.squad.findMany({
        where: { timeSlotId: updatedSquad.timeSlotId },
        orderBy: { createdAt: 'asc' }
      })

      // Find squads with the same base name pattern and get their numbers
      const similarSquads = timeSlotSquads.filter(s =>
        s.name.startsWith(baseSquadName) && s.id !== squadId
      )

      // Determine the next number
      let squadNumber = 1
      if (similarSquads.length > 0) {
        // Extract numbers from existing squad names
        const numbers = similarSquads.map(s => {
          const match = s.name.match(/\s+(\d+)$/)
          return match ? parseInt(match[1]) : 0
        })
        squadNumber = Math.max(...numbers, 0) + 1
      }

      const newSquadName = `${baseSquadName} ${squadNumber}`

      // Update squad name if it changed
      if (updatedSquad.name !== newSquadName) {
        await prisma.squad.update({
          where: { id: squadId },
          data: { name: newSquadName }
        })
      }
    }

    return NextResponse.json(member, { status: 201 })
  } catch (error) {
    console.error('Error adding athlete to squad:', error)
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// DELETE: Remove athlete from squad
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const user = await requireAuth()
    const { id: squadId } = await params
    const { athleteId } = await request.json()

    // Check permissions (coach or admin)
    if (user.role !== 'coach' && user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Only coaches and admins can manage squads' },
        { status: 403 }
      )
    }

    await prisma.squadMember.delete({
      where: {
        squadId_athleteId: {
          squadId,
          athleteId
        }
      }
    })

    // Auto-update squad name ONLY if it matches an auto-generated pattern
    const updatedSquad = await prisma.squad.findUnique({
      where: { id: squadId },
      include: {
        members: {
          include: {
            athlete: {
              include: {
                team: true
              }
            }
          }
        }
      }
    })

    // Check if squad name matches auto-generated pattern
    // Auto-generated names start with division name followed by number (e.g., "Open 1", "Varsity 2")
    // Custom names have additional text before division (e.g., "High Plains Drifters - Open 1")
    const divisionPrefixes = ['Open', 'Varsity', 'Intermediate', 'Junior Varsity', 'Novice', 'Collegiate', 'Unassigned']
    const isAutoGeneratedName = divisionPrefixes.some(prefix =>
      new RegExp(`^${prefix}\\s+\\d+$`).test(updatedSquad?.name || '')
    )

    if (updatedSquad && updatedSquad.members.length > 0 && isAutoGeneratedName) {
      // Get unique team IDs and names (filtering out null/undefined)
      const teams = updatedSquad.members
        .map(m => m.athlete.team)
        .filter((team): team is NonNullable<typeof team> => team !== null)

      const uniqueTeams = [...new Map(teams.map(t => [t.id, t])).values()]

      // Get divisions from squad members (use divisionOverride if available, otherwise division)
      const divisions = updatedSquad.members
        .map(m => m.athlete.divisionOverride || m.athlete.division)
        .filter(Boolean)

      const uniqueDivisions = [...new Set(divisions)]

      let baseSquadName: string

      // If multiple divisions (mixed divisions), use "Open" format
      if (uniqueDivisions.length > 1) {
        baseSquadName = 'Open'
      } else if (uniqueDivisions.length === 1 && uniqueDivisions[0]) {
        // Single division: use just the division name (e.g., "Varsity", "Junior Varsity", "Novice")
        baseSquadName = uniqueDivisions[0]
      } else {
        // Fallback
        baseSquadName = 'Open'
      }

      // Get all squads for this time slot to determine the number suffix
      const timeSlotSquads = await prisma.squad.findMany({
        where: { timeSlotId: updatedSquad.timeSlotId },
        orderBy: { createdAt: 'asc' }
      })

      // Find squads with the same base name pattern and get their numbers
      const similarSquads = timeSlotSquads.filter(s =>
        s.name.startsWith(baseSquadName) && s.id !== squadId
      )

      // Determine the next number
      let squadNumber = 1
      if (similarSquads.length > 0) {
        // Extract numbers from existing squad names
        const numbers = similarSquads.map(s => {
          const match = s.name.match(/\s+(\d+)$/)
          return match ? parseInt(match[1]) : 0
        })
        squadNumber = Math.max(...numbers, 0) + 1
      }

      const newSquadName = `${baseSquadName} ${squadNumber}`

      // Update squad name if it changed
      if (updatedSquad.name !== newSquadName) {
        await prisma.squad.update({
          where: { id: squadId },
          data: { name: newSquadName }
        })
      }
    }

    return NextResponse.json({ message: 'Athlete removed from squad' }, { status: 200 })
  } catch (error) {
    console.error('Error removing athlete from squad:', error)
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// PATCH: Update squad member positions (for drag-and-drop reordering)
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const user = await requireAuth()
    const { id: squadId } = await params
    const { updates } = await request.json()

    // Check permissions (coach or admin)
    if (user.role !== 'coach' && user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Only coaches and admins can manage squads' },
        { status: 403 }
      )
    }

    // Validate updates format: [{ athleteId: string, position: number }]
    if (!Array.isArray(updates) || updates.length === 0) {
      return NextResponse.json(
        { error: 'Invalid updates format. Expected array of {athleteId, position}' },
        { status: 400 }
      )
    }

    // Update positions in a transaction
    await prisma.$transaction(
      updates.map(({ athleteId, position }) =>
        prisma.squadMember.update({
          where: {
            squadId_athleteId: {
              squadId,
              athleteId
            }
          },
          data: { position }
        })
      )
    )

    return NextResponse.json({ message: 'Squad positions updated' }, { status: 200 })
  } catch (error) {
    console.error('Error updating squad positions:', error)
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

